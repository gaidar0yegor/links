#!/usr/bin/env python3
"""
Content Generator Service for Telegram Affiliate Bot
Handles content generation using Google Sheets templates and AI rewriting.
"""

import random
import re
from typing import Dict, List, Optional, Any
from services.sheets_api import sheets_api
from services.llm_client import OpenAIClient
from services.logger import bot_logger


class ContentGenerator:
    """Service for generating affiliate content using templates and AI."""

    def __init__(self):
        # Create LLM client dynamically to avoid caching issues
        self._llm_client = None
        self.templates_cache = {}
        self.hashtags_cache = {}
        self._load_templates()

    @property
    def llm_client(self):
        """Lazy initialization of LLM client."""
        if self._llm_client is None:
            from services.llm_client import OpenAIClient
            self._llm_client = OpenAIClient()
        return self._llm_client

    def _load_templates(self):
        """Load content templates from Google Sheets (hashtags removed - now generated by LLM)."""
        try:
            # Load content templates
            templates_data = sheets_api.get_sheet_data('content_templates')
            if templates_data and len(templates_data) > 1:
                headers = templates_data[0]
                col_indices = {header: idx for idx, header in enumerate(headers)}

                self.templates_cache = {}
                for row in templates_data[1:]:
                    if len(row) >= len(headers):
                        template_id = row[col_indices.get('template_id', 0)]
                        category = row[col_indices.get('category', 4)]
                        template_text = row[col_indices.get('template_text', 2)]
                        # Note: hashtags column removed - hashtags now generated by LLM

                        if category not in self.templates_cache:
                            self.templates_cache[category] = []

                        self.templates_cache[category].append({
                            'id': template_id,
                            'text': template_text,
                            # 'hashtags': hashtags  # Removed - now generated by LLM
                        })

            # Hashtags no longer loaded from Google Sheets - generated by LLM instead
            self.hashtags_cache = {}

            bot_logger.log_info("ContentGenerator", f"Loaded {len(self.templates_cache)} template categories (hashtags now generated by LLM)")

        except Exception as e:
            bot_logger.log_error("ContentGenerator", e, "Failed to load templates from Google Sheets")
            self.templates_cache = {}
            self.hashtags_cache = {}

    def get_fallback_template(self) -> Dict[str, str]:
        """Get the fallback template."""
        return {
            'text': '{product_name}\n\n‚ö´Ô∏èCorpo sottile dal design minimalista, perfetto per ogni ambiente\n\n‚ö´Ô∏è Due modalit√† di illuminazione ‚Äî luce calda e fredda ‚Äî ideale per lavoro, lettura o relax\n\n‚ö´Ô∏è Batteria integrata: utilizzabile senza fili, comodissima sul comodino o in viaggio\n\n‚ö´Ô∏è Regolatore touch della luminosit√† ‚Äî ajustabile con un solo tocco\n\nüíµ Prezzo: {price}\n\n‚≠êÔ∏è Rating: {rating}/5\n\nüîú Affrettati e ordina ora: {affiliate_link}\n\n#ad Come partner Amazon ricevo una commissione sugli acquisti idonei',
        }

    def get_random_template(self, category: str) -> Optional[Dict[str, str]]:
        """Get a random template for the specified category."""
        # Reload templates from Google Sheets on every request
        self._load_templates()
        
        if category not in self.templates_cache:
            # Try to find a generic template or fallback
            if 'Electronics' in self.templates_cache:
                category = 'Electronics'
            else:
                return None

        templates = self.templates_cache[category]
        if not templates:
            return None

        return random.choice(templates)

    def get_hashtags_for_category(self, category: str) -> str:
        """Get hashtags for the specified category."""
        return self.hashtags_cache.get(category, '#Affiliate #Product')

    async def generate_content(self, product_data: Dict[str, Any], category: Optional[str] = None, language: str = 'en') -> Optional[Dict[str, str]]:
        """
        Generate content for a product using templates and AI rewriting with product data.

        Args:
            product_data: Product information dictionary (supports both legacy and enriched formats)
            category: Product category (optional, will be inferred from product_data)

        Returns:
            Dictionary with 'content' and 'hashtags' keys (hashtags generated by LLM)
        """
        try:
            # If no category provided, use fallback template
            if not category:
                template = self.get_fallback_template()
                bot_logger.log_info("ContentGenerator", f"Using fallback template (no category provided)")
            else:
                # Try to get category-specific template from Google Sheets
                template = self.get_random_template(category)
                if not template:
                    # If no category-specific template found, use fallback
                    bot_logger.log_error("ContentGenerator", Exception(f"No template found for category: {category}"), "Using fallback template")
                    template = self.get_fallback_template()
                    bot_logger.log_info("ContentGenerator", f"Using fallback template (no template found for category: {category})")
                else:
                    template_id = template.get('id', 'unknown')
                    bot_logger.log_info("ContentGenerator", f"Using template ID: {template_id} for category: {category}")

            # Fill template variables - support both legacy and enriched data formats
            # Handle different key formats from various data sources
            product_name = (product_data.get('Title') or
                          product_data.get('title') or
                          product_data.get('name') or
                          product_data.get('product_name', 'Amazing Product'))

            # Handle rating - support both string and numeric formats
            rating_raw = (product_data.get('Rating') or
                         product_data.get('rating'))
            if rating_raw is not None and rating_raw != '' and rating_raw != 'None':
                try:
                    rating_val = float(rating_raw)
                    rating = f"{rating_val:.1f}"
                except (ValueError, TypeError):
                    rating = str(rating_raw)
            else:
                rating = '4.5'

            # Reviews are used for filtering only, not displayed in posts
            reviews_count = (product_data.get('ReviewsCount') or product_data.get('review_count') or 'N/A')


            # Handle price
            price_raw = (product_data.get('Price') or
                        product_data.get('price'))
            print(f"DEBUG: ContentGenerator - price_raw = {price_raw}, type = {type(price_raw)}")
            if price_raw is not None and price_raw != '' and price_raw != 'None':
                try:
                    # Handle decimal.Decimal, int, float types
                    from decimal import Decimal
                    if isinstance(price_raw, (int, float, Decimal)):
                        price = f"‚Ç¨{float(price_raw):.2f}"
                    else:
                        price = str(price_raw).strip()
                        # If it's already a formatted price string with Euro symbol, use it as-is
                        if not price.startswith('‚Ç¨'):
                            # Try to parse and format as Euro price
                            price_clean = price.replace('‚Ç¨', '').replace(',', '.').strip()
                            try:
                                price_val = float(price_clean)
                                price = f"‚Ç¨{price_val:.2f}"
                            except (ValueError, TypeError):
                                # If parsing fails, add Euro symbol
                                price = f"‚Ç¨{price}"
                except (ValueError, TypeError):
                    price = str(price_raw).strip()
            else:
                price = ''
            print(f"DEBUG: ContentGenerator - final price = '{price}'")

            affiliate_link = (product_data.get('AffiliateLink') or
                            product_data.get('affiliate_link') or
                            product_data.get('affiliate_link', '#'))

            # Format the template with safe replacement (missing placeholders become empty)
            template_text = template['text']
            placeholders = {
                'product_name': product_name,
                'rating': rating,
                'reviews_count': reviews_count,
                'affiliate_link': affiliate_link,
                'price': price,
                'hashtags': '',
                'category': category or '',
            }
            
            # Safe formatting - replace known placeholders, unknown ones become empty
            def safe_format(text: str, **kwargs) -> str:
                for key, value in kwargs.items():
                    text = text.replace(f'{{{key}}}', str(value) if value else '')
                # Remove any remaining {placeholder} that we don't know about
                text = re.sub(r'\{[a-zA-Z_][a-zA-Z0-9_]*\}', '', text)
                return text
            
            content = safe_format(template_text, **placeholders)

            # Use AI to generate the entire post, including features and hashtags
            full_post_content = await self._generate_full_post_with_ai(product_data, content, language)

            if not full_post_content:
                # AI generation failed - skip posting instead of using broken fallback
                print(f"‚ö†Ô∏è ContentGenerator - AI generation failed, skipping post (GPT unavailable)")
                return None

            return {
                'content': full_post_content,
                'hashtags': '',  # Hashtags are now part of the main content
                'template_id': template.get('id', 'fallback'),
                'category': category
            }

        except Exception as e:
            bot_logger.log_error("ContentGenerator", e, f"Content generation failed for product: {product_data.get('title', product_data.get('Title', 'Unknown'))}")
            return None

    async def _generate_full_post_with_ai(self, product_data: Dict[str, Any], base_content: str, language: str = 'en') -> Optional[str]:
        """Use AI to generate the complete post body, including features, translation, and hashtags."""
        try:
            # Get rewrite prompt from Google Sheets
            rewrite_prompt_data = sheets_api.get_sheet_data('rewrite_prompt')
            if rewrite_prompt_data and len(rewrite_prompt_data) > 1:
                base_prompt = rewrite_prompt_data[1][0]
            else:
                base_prompt = "Rewrite the provided text to be an engaging and persuasive social media post."

            # Build comprehensive product information, including features or description
            features = product_data.get('features') or product_data.get('Features', [])
            description = product_data.get('description') or product_data.get('Description', '')
            title = product_data.get('title') or product_data.get('Title', '')
            
            feature_text = ""
            if features and isinstance(features, list) and len(features) > 0:
                # Use features (preferred)
                feature_text = "\nKey Features:\n" + "\n".join(f"- {feature.strip()}" for feature in features)
            elif description and isinstance(description, str) and len(description.strip()) > 10:
                # Fallback to description if no features
                feature_text = f"\nProduct Description:\n{description.strip()}"
            elif title and len(title) > 100:
                # Long title can work as description fallback
                feature_text = f"\nProduct: {title}"
                print(f"‚ÑπÔ∏è ContentGenerator: Using long title as content source (len={len(title)})")
            else:
                # Neither features, description, nor long title - cannot generate quality content
                print(f"‚ö†Ô∏è ContentGenerator: No features/description and title too short ({len(title)} chars), skipping")
                return None

            product_info = f"""
---
PRODUCT INFORMATION TO USE:
Product Name: {product_data.get('Title', product_data.get('title', product_data.get('name', 'Unknown Product')))}
Rating: {product_data.get('Rating', product_data.get('rating', 'N/A'))}/5 stars
Review Count: {product_data.get('ReviewsCount', product_data.get('review_count', 'N/A'))} reviews
Price: {product_data.get('Price', product_data.get('price', 'N/A'))}{feature_text}
---
"""
            # Enhanced prompt that tells the AI to do everything
            enhanced_prompt = (
                f"{base_prompt}\n\n"
                "INSTRUCTIONS:\n"
                "1. Take the 'PRODUCT INFORMATION' provided and the 'BASE CONTENT' style guide.\n"
                "2. Create a complete, social media post.\n"
                "3. IMPORTANT: The entire response, including hashtags, MUST be in the target language.\n"
                "4. Do not include a placeholder for the link; it will be added later.\n"
                "5. CRITICAL: Only use features/information from the PRODUCT INFORMATION section. DO NOT invent or make up any features, specifications, or product details.\n\n"
                f"{product_info}\n\n"
                f"BASE CONTENT (use this as a style guide):\n{base_content}"
            )
            
            # Log summary of the prompt for debugging
            bot_logger.log_info("ContentGenerator", f"Generating content for: {product_data.get('Title', product_data.get('title', 'Unknown'))} (Prompt length: {len(enhanced_prompt)})")
            # bot_logger.log_info("ContentGenerator", f"Full LLM prompt:\n{enhanced_prompt}")

            # Use the LLM to generate the full post
            response = await self.llm_client.rewrite_text(enhanced_prompt, "", language=language, char_limit=800)

            return response.strip() if response else None

        except Exception as e:
            bot_logger.log_error("ContentGenerator", e, "AI full post generation failed")
            return None

    async def generate_post_content(self, product_data: Dict[str, Any], language: str = 'en', category: Optional[str] = None) -> Optional[Dict[str, str]]:
        """
        Generate complete post content including text, hashtags, and metadata.

        Args:
            product_data: Product information from Amazon/Google Sheets
            language: The target language for the content
            category: Product category (optional, will be inferred from product_data or campaign)

        Returns:
            Complete post data dictionary
        """
        try:
            content_result = await self.generate_content(product_data, category=category, language=language)

            if not content_result:
                # AI generation failed - return None to skip posting
                print(f"‚ö†Ô∏è generate_post_content: AI failed, returning None to skip post")
                return None

            # Add additional metadata, including features
            post_data = {
                'text': content_result['content'],
                'hashtags': content_result.get('hashtags', ''),
                'product_name': product_data.get('Title', product_data.get('title', '')),
                'product_link': product_data.get('AffiliateLink', product_data.get('affiliate_link', '')),
                'product_images': product_data.get('ImageURLs', product_data.get('image_urls', [])),
                'rating': product_data.get('Rating', product_data.get('rating', '')),
                'reviews_count': product_data.get('ReviewsCount', product_data.get('review_count', '')),
                'features': product_data.get('features', []),
                'category': content_result.get('category', 'General'),
                'template_id': content_result.get('template_id', 'fallback')
            }

            return post_data

        except Exception as e:
            bot_logger.log_error("ContentGenerator", e, "generate_post_content failed completely")
            # Return None to skip posting on error
            return None


# Global instance - lazy initialization
_content_generator = None

def get_content_generator():
    """Get the global content generator instance with lazy initialization."""
    global _content_generator
    if _content_generator is None:
        _content_generator = ContentGenerator()
    return _content_generator

# For backward compatibility
content_generator = get_content_generator()
