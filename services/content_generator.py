#!/usr/bin/env python3
"""
Content Generator Service for Telegram Affiliate Bot
Handles content generation using Google Sheets templates and AI rewriting.
"""

import random
from typing import Dict, List, Optional, Any
from services.sheets_api import sheets_api
from services.llm_client import OpenAIClient
from services.logger import bot_logger


class ContentGenerator:
    """Service for generating affiliate content using templates and AI."""

    def __init__(self):
        # Create LLM client dynamically to avoid caching issues
        self._llm_client = None
        self.templates_cache = {}
        self.hashtags_cache = {}
        self._load_templates()

    @property
    def llm_client(self):
        """Lazy initialization of LLM client."""
        if self._llm_client is None:
            from services.llm_client import OpenAIClient
            self._llm_client = OpenAIClient()
        return self._llm_client

    def _load_templates(self):
        """Load content templates from Google Sheets (hashtags removed - now generated by LLM)."""
        try:
            # Load content templates
            templates_data = sheets_api.get_sheet_data('content_templates')
            if templates_data and len(templates_data) > 1:
                headers = templates_data[0]
                col_indices = {header: idx for idx, header in enumerate(headers)}

                self.templates_cache = {}
                for row in templates_data[1:]:
                    if len(row) >= len(headers):
                        template_id = row[col_indices.get('template_id', 0)]
                        category = row[col_indices.get('category', 4)]
                        template_text = row[col_indices.get('template_text', 2)]
                        # Note: hashtags column removed - hashtags now generated by LLM

                        if category not in self.templates_cache:
                            self.templates_cache[category] = []

                        self.templates_cache[category].append({
                            'id': template_id,
                            'text': template_text,
                            # 'hashtags': hashtags  # Removed - now generated by LLM
                        })

            # Hashtags no longer loaded from Google Sheets - generated by LLM instead
            self.hashtags_cache = {}

            bot_logger.log_info("ContentGenerator", f"Loaded {len(self.templates_cache)} template categories (hashtags now generated by LLM)")

        except Exception as e:
            bot_logger.log_error("ContentGenerator", e, "Failed to load templates from Google Sheets")
            self.templates_cache = {}
            self.hashtags_cache = {}

    def get_fallback_template(self) -> Dict[str, str]:
        """Get the fallback template."""
        return {
            'text': '{product_name}\n\nâš«ï¸Corpo sottile dal design minimalista, perfetto per ogni ambiente\n\nâš«ï¸ Due modalitÃ  di illuminazione â€” luce calda e fredda â€” ideale per lavoro, lettura o relax\n\nâš«ï¸ Batteria integrata: utilizzabile senza fili, comodissima sul comodino o in viaggio\n\nâš«ï¸ Regolatore touch della luminositÃ  â€” ajustabile con un solo tocco\n\nðŸ’µ Prezzo: {price}\n\nâ­ï¸ Rating: {rating}/5\n\nðŸ”œ Affrettati e ordina ora: {affiliate_link}\n\n#ad Come partner Amazon ricevo una commissione sugli acquisti idonei',
        }

    def get_random_template(self, category: str) -> Optional[Dict[str, str]]:
        """Get a random template for the specified category."""
        if category not in self.templates_cache:
            # Try to find a generic template or fallback
            if 'Electronics' in self.templates_cache:
                category = 'Electronics'
            else:
                return None

        templates = self.templates_cache[category]
        if not templates:
            return None

        return random.choice(templates)

    def get_hashtags_for_category(self, category: str) -> str:
        """Get hashtags for the specified category."""
        return self.hashtags_cache.get(category, '#Affiliate #Product')

    async def generate_content(self, product_data: Dict[str, Any], category: Optional[str] = None, language: str = 'en') -> Optional[Dict[str, str]]:
        """
        Generate content for a product using templates and AI rewriting with product data.

        Args:
            product_data: Product information dictionary (supports both legacy and enriched formats)
            category: Product category (optional, will be inferred from product_data)

        Returns:
            Dictionary with 'content' and 'hashtags' keys (hashtags generated by LLM)
        """
        try:
            # If no category provided, use fallback template
            if not category:
                template = self.get_fallback_template()
                bot_logger.log_info("ContentGenerator", f"Using fallback template (no category provided)")
            else:
                # Try to get category-specific template from Google Sheets
                template = self.get_random_template(category)
                if not template:
                    # If no category-specific template found, use fallback
                    bot_logger.log_error("ContentGenerator", Exception(f"No template found for category: {category}"), "Using fallback template")
                    template = self.get_fallback_template()
                    bot_logger.log_info("ContentGenerator", f"Using fallback template (no template found for category: {category})")
                else:
                    template_id = template.get('id', 'unknown')
                    bot_logger.log_info("ContentGenerator", f"Using template ID: {template_id} for category: {category}")

            # Fill template variables - support both legacy and enriched data formats
            # Handle different key formats from various data sources
            product_name = (product_data.get('Title') or
                          product_data.get('title') or
                          product_data.get('name') or
                          product_data.get('product_name', 'Amazing Product'))

            # Handle rating - support both string and numeric formats
            rating_raw = (product_data.get('Rating') or
                         product_data.get('rating'))
            if rating_raw is not None and rating_raw != '' and rating_raw != 'None':
                try:
                    rating_val = float(rating_raw)
                    rating = f"{rating_val:.1f}"
                except (ValueError, TypeError):
                    rating = str(rating_raw)
            else:
                rating = '4.5'

            # Reviews are used for filtering only, not displayed in posts
            reviews_count = (product_data.get('ReviewsCount') or product_data.get('review_count') or 'N/A')


            # Handle price
            price_raw = (product_data.get('Price') or
                        product_data.get('price'))
            print(f"DEBUG: ContentGenerator - price_raw = {price_raw}, type = {type(price_raw)}")
            if price_raw is not None and price_raw != '' and price_raw != 'None':
                try:
                    # Handle decimal.Decimal, int, float types
                    from decimal import Decimal
                    if isinstance(price_raw, (int, float, Decimal)):
                        price = f"â‚¬{float(price_raw):.2f}"
                    else:
                        price = str(price_raw).strip()
                        # If it's already a formatted price string with Euro symbol, use it as-is
                        if not price.startswith('â‚¬'):
                            # Try to parse and format as Euro price
                            price_clean = price.replace('â‚¬', '').replace(',', '.').strip()
                            try:
                                price_val = float(price_clean)
                                price = f"â‚¬{price_val:.2f}"
                            except (ValueError, TypeError):
                                # If parsing fails, add Euro symbol
                                price = f"â‚¬{price}"
                except (ValueError, TypeError):
                    price = str(price_raw).strip()
            else:
                price = ''
            print(f"DEBUG: ContentGenerator - final price = '{price}'")

            affiliate_link = (product_data.get('AffiliateLink') or
                            product_data.get('affiliate_link') or
                            product_data.get('affiliate_link', '#'))

            # Format the template first
            template_text = template['text']
            content = template_text.format(
                product_name=product_name,
                rating=rating,
                reviews_count=reviews_count,
                affiliate_link=affiliate_link,
                price=price,
                hashtags=''  # Add dummy value for backward compatibility with old templates
            )

            # Use AI to generate the entire post, including features and hashtags
            full_post_content = await self._generate_full_post_with_ai(product_data, content, language)

            if not full_post_content:
                # Fallback if AI generation fails
                print(f"DEBUG: ContentGenerator - AI generation returned None, using fallback")
                # Build a simple fallback content block
                features = product_data.get('features') or product_data.get('Features', [])
                feature_bullets = ""
                if features and isinstance(features, list) and len(features) > 0:
                    feature_bullets = "\n\n" + "\n".join(f"â€¢ {feature.strip()}" for feature in features[:3])
                full_post_content = content + feature_bullets

            return {
                'content': full_post_content,
                'hashtags': '',  # Hashtags are now part of the main content
                'template_id': template.get('id', 'fallback'),
                'category': category
            }

        except Exception as e:
            bot_logger.log_error("ContentGenerator", e, f"Content generation failed for product: {product_data.get('title', product_data.get('Title', 'Unknown'))}")
            return None

    async def _generate_full_post_with_ai(self, product_data: Dict[str, Any], base_content: str, language: str = 'en') -> Optional[str]:
        """Use AI to generate the complete post body, including features, translation, and hashtags."""
        try:
            # Get rewrite prompt from Google Sheets
            rewrite_prompt_data = sheets_api.get_sheet_data('rewrite_prompt')
            if rewrite_prompt_data and len(rewrite_prompt_data) > 1:
                base_prompt = rewrite_prompt_data[1][0]
            else:
                base_prompt = "Rewrite the provided text to be an engaging and persuasive social media post."

            # Build comprehensive product information, including features
            features = product_data.get('features') or product_data.get('Features', [])
            feature_text = ""
            if features and isinstance(features, list) and len(features) > 0:
                feature_text = "\nKey Features:\n" + "\n".join(f"- {feature.strip()}" for feature in features)

            product_info = f"""
---
PRODUCT INFORMATION TO USE:
Product Name: {product_data.get('Title', product_data.get('name', 'Unknown Product'))}
Rating: {product_data.get('Rating', product_data.get('rating', 'N/A'))}/5 stars
Review Count: {product_data.get('ReviewsCount', product_data.get('review_count', 'N/A'))} reviews
Price: {product_data.get('Price', product_data.get('price', 'N/A'))}{feature_text}
---
"""
            # Enhanced prompt that tells the AI to do everything
            enhanced_prompt = (
                f"{base_prompt}\n\n"
                "INSTRUCTIONS:\n"
                "1. Take the 'PRODUCT INFORMATION' provided and the 'BASE CONTENT' style guide.\n"
                "2. Create a complete, engaging social media post.\n"
                "3. IMPORTANT: The entire response, including hashtags, MUST be in the target language.\n"
                "4. Naturally integrate the key features, price, and rating into the post.\n"
                "6. Do not include a placeholder for the link; it will be added later.\n\n"
                f"{product_info}\n\n"
                f"BASE CONTENT (use this as a style guide):\n{base_content}"
            )
            
            # Log the full prompt for debugging
            bot_logger.log_info("ContentGenerator", f"Full LLM prompt:\n{enhanced_prompt}")

            # Use the LLM to generate the full post
            response = await self.llm_client.rewrite_text(enhanced_prompt, "", language=language, char_limit=800)

            return response.strip() if response else None

        except Exception as e:
            bot_logger.log_error("ContentGenerator", e, "AI full post generation failed")
            return None

    async def generate_post_content(self, product_data: Dict[str, Any], language: str = 'en', category: Optional[str] = None) -> Optional[Dict[str, str]]:
        """
        Generate complete post content including text, hashtags, and metadata.

        Args:
            product_data: Product information from Amazon/Google Sheets
            language: The target language for the content
            category: Product category (optional, will be inferred from product_data or campaign)

        Returns:
            Complete post data dictionary
        """
        try:
            content_result = await self.generate_content(product_data, category=category, language=language)

            if not content_result:
                # Return fallback content if generation failed - include price if available
                title = product_data.get('Title', product_data.get('title', 'Amazing Product'))
                price_raw = (product_data.get('Price') or product_data.get('price'))
                price_text = ""
                if price_raw is not None and price_raw != '' and price_raw != 'None':
                    try:
                        from decimal import Decimal
                        if isinstance(price_raw, (int, float, Decimal)):
                            price_text = f"ðŸ’° **Price: â‚¬{float(price_raw):.2f}**\n\n"
                        else:
                            price_clean = str(price_raw).replace('â‚¬', '').replace(',', '.').strip()
                            try:
                                price_val = float(price_clean)
                                price_text = f"ðŸ’° **Price: â‚¬{price_val:.2f}**\n\n"
                            except (ValueError, TypeError):
                                if str(price_raw).startswith('â‚¬'):
                                    price_text = f"ðŸ’° **Price: {price_raw}**\n\n"
                    except (ValueError, TypeError):
                        pass

                return {
                    'text': f"âœ¨ **GREAT DEAL!** {title}\n\n{price_text}Check out this amazing product!",
                    'hashtags': '',
                    'product_name': product_data.get('Title', product_data.get('title', '')),
                    'product_link': product_data.get('AffiliateLink', product_data.get('affiliate_link', '')),
                    'product_images': product_data.get('ImageURLs', product_data.get('image_urls', [])),
                    'rating': product_data.get('Rating', product_data.get('rating', '')),
                    'reviews_count': product_data.get('ReviewsCount', product_data.get('review_count', '')),
                    'features': product_data.get('features', []),
                    'category': 'General',
                    'template_id': 'fallback'
                }

            # Add additional metadata, including features
            post_data = {
                'text': content_result['content'],
                'hashtags': content_result.get('hashtags', ''),
                'product_name': product_data.get('Title', product_data.get('title', '')),
                'product_link': product_data.get('AffiliateLink', product_data.get('affiliate_link', '')),
                'product_images': product_data.get('ImageURLs', product_data.get('image_urls', [])),
                'rating': product_data.get('Rating', product_data.get('rating', '')),
                'reviews_count': product_data.get('ReviewsCount', product_data.get('review_count', '')),
                'features': product_data.get('features', []),
                'category': content_result.get('category', 'General'),
                'template_id': content_result.get('template_id', 'fallback')
            }

            return post_data

        except Exception as e:
            bot_logger.log_error("ContentGenerator", e, "generate_post_content failed completely")
            # Ultimate fallback
            return {
                'text': f"âœ¨ **GREAT DEAL!** {product_data.get('Title', product_data.get('title', 'Amazing Product'))}\n\nCheck out this amazing product!",
                'hashtags': '',
                'product_name': product_data.get('Title', product_data.get('title', '')),
                'product_link': product_data.get('AffiliateLink', product_data.get('affiliate_link', '')),
                'product_images': product_data.get('ImageURLs', product_data.get('image_urls', [])),
                'rating': product_data.get('Rating', product_data.get('rating', '')),
                'reviews_count': product_data.get('ReviewsCount', product_data.get('review_count', '')),
                'features': product_data.get('features', []),
                'category': 'General',
                'template_id': 'fallback'
            }


# Global instance - lazy initialization
_content_generator = None

def get_content_generator():
    """Get the global content generator instance with lazy initialization."""
    global _content_generator
    if _content_generator is None:
        _content_generator = ContentGenerator()
    return _content_generator

# For backward compatibility
content_generator = get_content_generator()
